#!/usr/bin/python

import argparse
import logging
from serial import Serial
import time, datetime

#logging.basicConfig(level=logging.DEBUG)

class DataLogger(object):
    def __init__(self, device=None):
        if device == None:
            # TODO: Look for device more intelligently
            device = '/dev/ttyACM0'

        self._dev = Serial(device, baudrate=115200)

    def _write_cmd(self, cmd):
        logging.debug('command: %s' % cmd)
        self._dev.write(cmd + '\n')
        
    def _read_reply(self):
        a = []
        while True:
            l = self._dev.readline().strip()
            if len(l.strip()) == 0:
                logging.debug('reply: %s' % a)
                return a
            else:
                a.append(l)

    def _read_single_reply(self):
        """ Read a single-line reply """
        reply = self._read_reply()
        if len(reply) != 1:
            raise RuntimeError('invalid reply: %s' % reply)
        return reply[0]

    def _read_reply_value(self):
        reply = self._read_single_reply()
        return reply.split('=')[1].strip()

    def set_verbose(self, verbose):
        self._write_cmd('v=%d' % verbose)
        return bool(int(self._read_reply_value()))
        
    def get_sample_count(self):
        self._write_cmd('n')
        return int(self._read_reply_value())

    def _parse_sample(self, line):
        l = line.split()
        if len(l) != 3:
            raise RuntimeError("Invalid sample line")
        time = int(l[0])
        sensor = int(l[1])
        value = float(l[2])
        return (time, sensor, value)

    def fetch_samples(self, start, count):
        self._write_cmd('g %d %d' % (start, count))
        for l in self._read_reply():
            yield self._parse_sample(l)

    def set_acquisition_state(self, running):
        self._write_cmd('a=%d' % running)
        return bool(int(self._read_reply_value()))

    def get_acquisition_state(self):
        self._write_cmd('a')
        return bool(int(self._read_reply_value()))

    def identify_flash(self):
        self._write_cmd('i')
        return self._read_single_reply()

    def get_rtc_time(self):
        self._write_cmd('t')
        return int(self._read_reply_value())

    def set_rtc_time(self, time):
        self._write_cmd('t=%d' % time)
        return self._read_single_reply()

    def get_last_sample(self):
        self._write_cmd('l')
        for l in self._read_reply():
            yield self._parse_sample(l)

    def force_sample(self):
        self._write_cmd('f')
        self._read_reply()

    def set_sample_period(self, period):
        self._write_cmd('T=%d' % period)
        self._read_reply()

    def get_sample_period(self):
        self._write_cmd('T')
        return int(self._read_reply_value())

    def list_sensors(self):
        self._write_cmd('s')
        for l in self._read_reply():
            parts = l.split()
            sensor_id = int(parts[0])
            name = parts[1]
            unit = parts[2]
            yield (sensor_id, name, unit)

    def get_last_sample(self):
        self._write_cmd('l')
        for l in self._read_reply():
            parts = l.split()
            last_sample_time = int(parts[0])
            sensor_id = int(parts[1])
            last_value = float(parts[2])
            yield (last_sample_time, sensor_id, last_value)

def fetch_handler(logger, args):
    nsamples = logger.get_sample_count()

    start = 0
    count = nsamples
    if args.start is not None:
        start = args.start
        count = nsamples - start

    if args.count is not None:
        if start + args.count > nsamples:
            raise RuntimeError('Too many samples requested')
        count = args.count

    print("# time\tsensor\tvalue")
    for sample in logger.fetch_samples(start, count):
        (time, sensor, value) = sample
        print("%-10d\t%-2d   \t%-3.4f" % (time, sensor, value))

def start_handler(logger, args):
    logger.set_acquisition_state(True)
    t = logger.get_sample_period()
    print "Acquisition started sampling every %d seconds" % t

def stop_handler(logger, args):
    logger.set_acquisition_state(False)
    print "Acquisition stopped"

def stop_handler(logger, args):
    logger.stop_sampling()

def status_handler(logger, args):
    count = logger.get_sample_count()
    print('samples collected: %d' % count)
    print(logger.identify_flash())
    t = logger.get_rtc_time()
    dt = datetime.datetime.utcfromtimestamp(t).isoformat()
    print('RTC time: %s = %d' % (dt, t))
    print('sample period: %d seconds' % logger.get_sample_period())
    print('acquisition: %s' %
          ('running' if logger.get_acquisition_state() else 'stopped'))
    print('')
    print("sensors:")
    for (sid, name, unit) in logger.list_sensors():
        print("%-2d\t%-15s\t%-10s" % (sid, name, unit))

def print_last_handler(logger, args):
    if args.force_sample:
        logger.force_sample()
        time.sleep(0.1)
    print("# time            sensor      value")
    for (time, sensor, value) in logger.get_last_sample():
        print("%-10d        %-2d          %-3.4f" % (time, sensor, value))

def set_rtc_handler(logger, args):
    epoch_time = time.time()
    logger.set_rtc_time(epoch_time)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Interface to mchck data-logger firmware")
    parser.add_argument('-d', '--device', metavar='FILE', help='data-logger ACM device')
    subparsers = parser.add_subparsers(help='sub-command help', dest='mode')

    fetch = subparsers.add_parser('fetch', help='fetch samples from device')
    fetch.set_defaults(func=fetch_handler)
    fetch.add_argument('-s', '--start', type=int, help='sample index to start from')
    fetch.add_argument('-n', '--count', type=int, help='number of samples to dump')

    start = subparsers.add_parser('start', help='start sample acquisition')
    start.set_defaults(func=start_handler)
    start.add_argument('-T', '--sample-period', type=int, metavar='SECONDS',
                       help='time between samples in seconds')

    start = subparsers.add_parser('stop', help='stop sample acquisition')
    start.set_defaults(func=stop_handler)

    status = subparsers.add_parser('status', help='fetch samples from device')
    status.set_defaults(func=status_handler)

    set_rtc = subparsers.add_parser('set-rtc', help='set the real-time clock time on the device')
    set_rtc.set_defaults(func=set_rtc_handler)

    last = subparsers.add_parser('last', help='fetch samples from device')
    last.add_argument('-f', '--force-sample', action='store_true', help='Force a sample')
    last.set_defaults(func=print_last_handler)

    args = parser.parse_args()
    logger = DataLogger(args.device)
    if args.func:
        args.func(logger, args)
